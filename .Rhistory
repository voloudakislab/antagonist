x.cdr <- MultiWAS::return_df(x.cdr)
x.cdr <- as.data.table(dplyr::left_join(x.cdr, ref.drug))
x.cdr$readily.repurposable <- !is.na(x.cdr$clinical_phase)
# Keep at least min.experiments
x.cdr[, N_experiments := length(AvgRank), by = pert_iname]
x.cdr <- x.cdr[N_experiments >= min.experiments.n]
}
### GTP ###
if (length(x.gtp) != 0) {
x.gtp <- do.call(
rbind,
lapply(
x.gtp,
FUN = function(x) {
MultiWAS::return_df(x.gtp)
}))
# Keep at least min.experiments
x.gtp[, N_experiments := length(AvgRank), by = pert_iname]
x.gtp <- x.gtp[N_experiments >= min.experiments.n]
}
# #################################
# # Density plot for IL10RB (paper)
# x$shRNA <- paste0("other (n=",length(x[pert_iname != "IL10RB"]$shRNA),")")
# x[pert_iname == "IL10RB"]$shRNA <- paste0("IL10RB (n=",length(x[pert_iname == "IL10RB"]$shRNA),")")
# IL10RBplot <- ggpubr::ggdensity( # https://rpkgs.datanovia.com/ggpubr/reference/ggdensity.html
#   x, x = "AvgRank", add = "mean", xlab = "Signature AvgRank",
#   color = "shRNA", fill = "shRNA",
#   palette = vector_to_colors(unique(x$shRNA)) # , rug = TRUE
#   )
# cowplot::ggsave2( paste0(output.dir, "/IL10RB_AvgRank_distribution_square.pdf") , IL10RBplot, height = 4, width = 4 )
# cowplot::ggsave2( paste0(output.dir, "/IL10RB_AvgRank_distribution_landscape.pdf") , IL10RBplot, height = 3, width = 10 )
# This is no longer used, since most signatures come only from specific cell lines.
# # Remove those that were done in irrelevant cell lines - keeping lung and immune cell lines
# if (discard.non.relevant.cell.lines) {
#   x <- as.data.table(inner_join(x, cell_lines))
#   x <- x[!is.na(clinical_phase)]
# }
lapply(
gwass,
FUN = function(thisgwas) {
message(paste0("Now processing ", thisgwas))
this.output.dir <- paste0(output.dir, "/", thisgwas, "/")
MultiWAS::gv_dir.create(this.output.dir)
### MAIN SCRIPT ###
lapply(
list(x.cdr, x.gtp),
FUN = function(x) {
if (length(x) != 0) {
# Limit to GWAS of interest
x <- x[gwas == thisgwas]
# Limit to models of interest
if (!is.na(limit.models.to[1])) x <- x[model_ID %in% limit.models.to]
this.output.dir <- paste0(
this.output.dir, "/",
MultiWAS::make_java_safe(paste(limit.models.to, collapse = "_X_"))
, "/")
MultiWAS::gv_dir.create(this.output.dir)
###########################
# Density plot for Avg rank
d.plot <- ggpubr::ggdensity( # https://rpkgs.datanovia.com/ggpubr/reference/ggdensity.html
data.frame(Type = paste(x$pert_type,collapse = "|"),
AvgRank = as.numeric(x$AvgRank)),
x = "AvgRank", add = "mean", xlab = "Signature AvgRank")
cowplot::ggsave2( paste0(this.output.dir, "/AvgRank_distribution_square.pdf") , d.plot, height = 4, width = 4 )
cowplot::ggsave2( paste0(this.output.dir, "/AvgRank_distribution_landscape.pdf") , d.plot, height = 3, width = 8 )
########################
# Calculating statistics
# hist(x$AvgRank) # Seems to be following the gaussian distribution
# avg.rank.mean <- mean(x$AvgRank)
avg.rank.sd   <- sd(x$AvgRank)
message("Calculating the MW statistic (WRST)...")
# Calculate MW statistic (WRST)
x <- as.data.table(dplyr::left_join(
x,
do.call(rbind,pbmclapply(
unique(x$pert_iname),
FUN = function(i){
mw.res <- wilcox.test(
x[pert_iname == i]$AvgRank,
x[pert_iname != i]$AvgRank,
paired = FALSE,
conf.int = T) # conf.int = T is required to get the estimate
data.frame(
pert_iname             = i,
Compound.MW.p          = mw.res$p.value,
Compound.pseudo.zscore = -1*(mw.res$estimate/avg.rank.sd) # the estimate is a deviation from the median/mean AvgRank and we are dividing that by the sd of AvgRank
)
}, mc.cores = n.cores ))
))
fwrite(x, paste0(this.output.dir, "/", thisgwas,"_",
ifelse(unique(x$pert_type)[1] == "trt_cp", "cdr","gtp"),
"_signature_level.csv.gz"))
# Aggregate at the level of compound
x$Rank <- as.numeric(NA) # reset
x[, AvgRank := mean(AvgRank), by = pert_iname]
x[, perm.p.all:= paste(sort(perm.p), collapse=";"), by = pert_iname ] # save permutation values
if (unique(x$pert_type)[1] == "trt_cp") {
## CDR specific code
compound.level = unique(x[, c(
"gwas",
"pert_iname", "Rank", "AvgRank", "Compound.MW.p", "Compound.pseudo.zscore",
"clinical_phase",   "moa", "target", "disease_area", "indication",
"N_experiments", "perm.p.all")])
} else {
compound.level = unique(x[, c(
"gwas",
"pert_iname", "Rank", "AvgRank", "Compound.MW.p",
"Compound.pseudo.zscore",  "N_experiments", "perm.p.all")])
## GTP specific code
}
compound.level$Rank <- rank(compound.level$AvgRank) # replace Rank
compound.level      <- compound.level[order(Rank)]
if (unique(x$pert_type)[1] == "trt_cp") {
## CDR specific code for moa (Mechanism of action)
#### MOA ####
# Aggregate at the level of moa
moa.repurp      <- compound.level[, c("moa", "AvgRank")]
# https://stackoverflow.com/questions/61684587/r-data-table-split-a-row-into-multiple-rows-based-on-string-values
# Exclude those that don't have moa
moa.repurp <- moa.repurp[!is.na(moa)]
moa.repurp      = moa.repurp[moa != "unknown"]
moa.repurp <- moa.repurp[, .(moa = unlist(tstrsplit(moa, "\\|", type.convert = TRUE))), by = "AvgRank"]
moa.repurp[, N_compounds_moa := length(AvgRank), by = moa]
moa.repurp      = moa.repurp[N_compounds_moa > 1] # only if there are more than 2
moa.avg.rank.sd = sd(moa.repurp$AvgRank)
# 96 unique MOA
message("Running mechanism of action enrichment...")
moa.repurp <- as.data.table(dplyr::left_join(
moa.repurp,
do.call(rbind,pbmclapply(
unique(moa.repurp$moa),
FUN = function(i){
mw.res <- wilcox.test(
moa.repurp[moa == i]$AvgRank,
moa.repurp[moa != i]$AvgRank,
paired = FALSE,
conf.int = T) # conf.int = T is required to get the estimate
data.frame(
moa               = i,
MOA.MW.p          = mw.res$p.value,
MOA.pseudo.zscore = -1*(mw.res$estimate/moa.avg.rank.sd) # the estimate is a deviation from the median/mean AvgRank and we are dividing that by the sd of AvgRank
)
}, mc.cores = detectCores()-2 ))
))
moa.repurp[, AvgRank_moa := mean(AvgRank), by = moa]
moa.repurp = unique(moa.repurp[, c("moa", "AvgRank_moa", "MOA.pseudo.zscore",
"N_compounds_moa", "MOA.MW.p")])
moa.repurp$Rank_moa <- rank(moa.repurp$AvgRank_moa)
# moa.repurp$Rank_moa_percentile <- my_percent(moa.repurp$Rank_moa_percentile/length(unique(moa.repurp$moa)))
# moa.repurp$Rank_moa_percentile <- moa.repurp$Rank_moa_percentile/length(unique(moa.repurp$moa))
moa.repurp <- moa.repurp[order(Rank_moa)]
moa.repurp$MOA.MW.FDR <- p.adjust(moa.repurp$MOA.MW.p, method = "fdr")
fwrite(moa.repurp, paste0(this.output.dir, "/", thisgwas, "_",
ifelse(unique(x$pert_type)[1] == "trt_cp", "cdr","gtp"),
"_moa_level.csv"))
#### TARGET ####
# Aggregate at the level of target
target.repurp      <- compound.level[, c("target", "AvgRank")]
# https://stackoverflow.com/questions/61684587/r-data-table-split-a-row-into-multiple-rows-based-on-string-values
# Exclude those that don't have target
target.repurp <- target.repurp[!is.na(target)]
target.repurp      = target.repurp[target != "unknown"]
target.repurp <- target.repurp[, .(target = unlist(tstrsplit(target, "\\|", type.convert = TRUE))), by = "AvgRank"]
target.repurp[, N_compounds_target := length(AvgRank), by = target]
target.repurp      = target.repurp[N_compounds_target > 1] # only if there are more than 2
target.avg.rank.sd = sd(target.repurp$AvgRank)
message("Running target enrichment...")
target.repurp <- as.data.table(dplyr::left_join(
target.repurp,
do.call(rbind,pbmclapply(
unique(target.repurp$target),
FUN = function(i){
mw.res <- wilcox.test(
target.repurp[target == i]$AvgRank,
target.repurp[target != i]$AvgRank,
paired = FALSE,
conf.int = T) # conf.int = T is required to get the estimate
data.frame(
target               = i,
target.MW.p          = mw.res$p.value,
target.pseudo.zscore = -1*(mw.res$estimate/target.avg.rank.sd) # the estimate is a deviation from the median/mean AvgRank and we are dividing that by the sd of AvgRank
)
}, mc.cores = detectCores()-2 ))
))
target.repurp[, AvgRank_target := mean(AvgRank), by = target]
target.repurp = unique(target.repurp[, c("target", "AvgRank_target", "target.pseudo.zscore",
"N_compounds_target", "target.MW.p")])
target.repurp$Rank_target <- rank(target.repurp$AvgRank_target)
target.repurp <- target.repurp[order(Rank_target)]
target.repurp$target.MW.FDR <- p.adjust(target.repurp$target.MW.p, method = "fdr")
fwrite(target.repurp, paste0(this.output.dir, "/", thisgwas, "_",
ifelse(unique(x$pert_type)[1] == "trt_cp", "cdr","gtp"),
"_target_level.csv"))
#### disease_area ####
# Aggregate at the level of disease_area
disease_area.repurp      <- compound.level[, c("disease_area", "AvgRank")]
# https://stackoverflow.com/questions/61684587/r-data-table-split-a-row-into-multiple-rows-based-on-string-values
# Exclude those that don't have disease_area
disease_area.repurp <- disease_area.repurp[!is.na(disease_area)]
disease_area.repurp      = disease_area.repurp[disease_area != "unknown"]
disease_area.repurp <- disease_area.repurp[, .(disease_area = unlist(tstrsplit(disease_area, "\\|", type.convert = TRUE))), by = "AvgRank"]
disease_area.repurp[, N_compounds_disease_area := length(AvgRank), by = disease_area]
disease_area.repurp      = disease_area.repurp[N_compounds_disease_area > 1] # only if there are more than 2
disease_area.avg.rank.sd = sd(disease_area.repurp$AvgRank)
message("Running disease area enrichment...")
disease_area.repurp <- as.data.table(dplyr::left_join(
disease_area.repurp,
do.call(rbind,pbmclapply(
unique(disease_area.repurp$disease_area),
FUN = function(i){
mw.res <- wilcox.test(
disease_area.repurp[disease_area == i]$AvgRank,
disease_area.repurp[disease_area != i]$AvgRank,
paired = FALSE,
conf.int = T) # conf.int = T is required to get the estimate
data.frame(
disease_area               = i,
disease_area.MW.p          = mw.res$p.value,
disease_area.pseudo.zscore = -1*(mw.res$estimate/disease_area.avg.rank.sd) # the estimate is a deviation from the median/mean AvgRank and we are dividing that by the sd of AvgRank
)
}, mc.cores = detectCores()-2 ))
))
disease_area.repurp[, AvgRank_disease_area := mean(AvgRank), by = disease_area]
disease_area.repurp = unique(disease_area.repurp[, c("disease_area", "AvgRank_disease_area", "disease_area.pseudo.zscore",
"N_compounds_disease_area", "disease_area.MW.p")])
disease_area.repurp$Rank_disease_area <- rank(disease_area.repurp$AvgRank_disease_area)
disease_area.repurp <- disease_area.repurp[order(Rank_disease_area)]
disease_area.repurp$disease_area.MW.FDR <- p.adjust(disease_area.repurp$disease_area.MW.p, method = "fdr")
fwrite(disease_area.repurp, paste0(this.output.dir, "/", thisgwas, "_",
ifelse(unique(x$pert_type)[1] == "trt_cp", "cdr","gtp"),
"_disease_area_level.csv"))
#### indication ####
# Aggregate at the level of indication
indication.repurp      <- compound.level[, c("indication", "AvgRank")]
# https://stackoverflow.com/questions/61684587/r-data-table-split-a-row-into-multiple-rows-based-on-string-values
# Exclude those that don't have indication
indication.repurp <- indication.repurp[!is.na(indication)]
indication.repurp      = indication.repurp[indication != "unknown"]
indication.repurp <- indication.repurp[, .(indication = unlist(tstrsplit(indication, "\\|", type.convert = TRUE))), by = "AvgRank"]
indication.repurp[, N_compounds_indication := length(AvgRank), by = indication]
indication.repurp      = indication.repurp[N_compounds_indication > 1] # only if there are more than 2
indication.avg.rank.sd = sd(indication.repurp$AvgRank)
message("Running indication enrichment...")
indication.repurp <- as.data.table(dplyr::left_join(
indication.repurp,
do.call(rbind,pbmclapply(
unique(indication.repurp$indication),
FUN = function(i){
mw.res <- wilcox.test(
indication.repurp[indication == i]$AvgRank,
indication.repurp[indication != i]$AvgRank,
paired = FALSE,
conf.int = T) # conf.int = T is required to get the estimate
data.frame(
indication               = i,
indication.MW.p          = mw.res$p.value,
indication.pseudo.zscore = -1*(mw.res$estimate/indication.avg.rank.sd) # the estimate is a deviation from the median/mean AvgRank and we are dividing that by the sd of AvgRank
)
}, mc.cores = detectCores()-2 ))
))
indication.repurp[, AvgRank_indication := mean(AvgRank), by = indication]
indication.repurp = unique(indication.repurp[, c("indication", "AvgRank_indication", "indication.pseudo.zscore",
"N_compounds_indication", "indication.MW.p")])
indication.repurp$Rank_indication <- rank(indication.repurp$AvgRank_indication)
indication.repurp <- indication.repurp[order(Rank_indication)]
indication.repurp$indication.MW.FDR <- p.adjust(indication.repurp$indication.MW.p, method = "fdr")
fwrite(indication.repurp, paste0(this.output.dir, "/", thisgwas, "_",
ifelse(unique(x$pert_type)[1] == "trt_cp", "cdr","gtp"),
"_indication_level.csv"))
# Compile and save
# This is imperfect for compounds that have more than one moa
compound.level <- as.data.table(dplyr::left_join(
compound.level, moa.repurp[, c("moa", "Rank_moa", "MOA.pseudo.zscore",
"MOA.MW.p", "MOA.MW.FDR")]))
fwrite(compound.level, paste0(this.output.dir, "/", thisgwas, "_",
ifelse(unique(x$pert_type)[1] == "trt_cp", "cdr","gtp"),
"_all_compound_level.csv"))
# Filter to only Phase 3 and lauched
compound.level$Compound.MW.FDR <- as.numeric(NA)
compound.level[clinical_phase %in% c("Phase 3", "Launched")]$Compound.MW.FDR <-
p.adjust(compound.level[clinical_phase %in% c("Phase 3", "Launched")]$Compound.MW.p, method = "fdr")
# compound.level$Compound.MW.FDR <- p.adjust(compound.level$Compound.MW.p, method = "fdr")
compound.level <- compound.level[
, c("pert_iname", "clinical_phase", "Rank", "AvgRank", "Compound.MW.p",
"Compound.MW.FDR", "Compound.pseudo.zscore", "moa", "Rank_moa",
"MOA.pseudo.zscore", "MOA.MW.p", "MOA.MW.FDR", "target", "disease_area",
"indication", "N_experiments", "perm.p.all")]
fwrite(compound.level, paste0(this.output.dir, "/", thisgwas, "_",
ifelse(unique(x$pert_type)[1] == "trt_cp", "cdr","gtp"),
"_P3_and_launched_compound_level.csv"))
compound.level <- compound.level[clinical_phase=="Launched"] # 201 compounds
compound.level$Rank <- rank(compound.level$Rank) # rerank
column.order <- names(compound.level)
moa.ranks <- unique(compound.level[,c("moa", "Rank_moa")])
moa.ranks <- moa.ranks[!is.na(Rank_moa)]
moa.ranks$MOA.Rank <- rank(moa.ranks$Rank_moa) # rerank
moa.ranks[, Rank_moa := NULL]
compound.level[, Rank_moa := NULL] # remove
compound.level <- as.data.table(dplyr::left_join(compound.level, moa.ranks))
fwrite(compound.level, paste0(this.output.dir, "/", thisgwas, "_",
ifelse(unique(x$pert_type)[1] == "trt_cp", "cdr","gtp"),
"_launched_compound_level.csv"))
} else {
### GTP SPECIFIC SCRIPTS ###
compound.level$Rank <- rank(compound.level$AvgRank) # replace Rank
compound.level$Compound.MW.FDR <- p.adjust(compound.level$Compound.MW.p, method = "fdr")
compound.level <- compound.level[order(Rank)][
, c("pert_iname", "Rank", "AvgRank", "Compound.MW.p",
"Compound.pseudo.zscore", "Compound.MW.FDR",
"N_experiments", "perm.p.all")]  }
fwrite(compound.level, paste0(this.output.dir, "/", thisgwas, "_",
ifelse(unique(x$pert_type)[1] == "trt_cp", "cdr","gtp"),
"_launched_compound_level.csv"))
} # section of analysis specific scripts done.
} # function for thisgwas loop ends here
) # lapply loop for CDR and GTP dataframes
} # lapply function for all GWASs
) # lapply loop for all GWASs
# TODO: Compile the results and save as xls add this description as you do in MultiWAS package
# pert_iname: common name of compound
# clinical_phase: clinical phase of compound as per 2018-09-07
# Rank: Overall Rank of compound
# AvgRank: average of all average ranks of compounds during permutation analysis
# Compound.WRS.p: Wilcoxon rank sum test p value for placement out of all experiments and GWASs if applicable
# moa: mechanism of action
# Rank_moa_percentile: moa ranking percentile (only if 2 or more drugs per moa)
# MOA.WRS.P: Wilcoxon rank sum test p value for placement out of all compounds (were already ranked at compound level)
# target: molecular targets
# disease_area:
# indication:
# N_experiments: number of experiments for each TWAS
# perm.p.all: all perm.p values collapsed
# return(compound.level)
}
library(antagonist)
library(antagonism)
library(antagonist)
antagonist::aggregate_and_prioritize()
as.character(MultiWAS::make_java_safe(paste(limit.models.to, collapse = "_X_")))
limit.models.to                 = NA
as.character(MultiWAS::make_java_safe(paste(limit.models.to, collapse = "_X_")))
modelprefix <- as.character(MultiWAS::make_java_safe(paste(limit.models.to, collapse = "_X_")))
is.na(modelprefix)
modelprefix <- as.character(MultiWAS::make_java_safe(paste(limit.models.to, collapse = "_X_")))
if (modelprefix == "NA") modelprefix <- "ALL"
paste0(
this.output.dir, "/",
modelprefix, "/")
modelprefix
library(antagonist)
library(antagonist)
library(antagonist)
library(antagonist)
library(antagonist)
library(antagonist)
library(antagonist)
eval("c(1,3)")
eval(parse(text="c(1,3)"))
eval("NULL")
eval(parse(text ="NULL"))
eval(parse(text ="/home/georgios/1kg.feature.correlation.pdf"))
eval(parse(text ="3"))
eval(parse(text ="parallel::detectCores()-2"))
eval(parse(text ="SIG.INFO.20211120"))
#' Parse LSF project recipe file
#'
#' @param recipe.file recipe file
#' @return A list file with all included parameters
#' @keywords antagonism step1 LSF
#' @export
parse_recipe <- function(
recipe.file
){
x <- return_df(recipe.file)
recipe <- list()
if(x[variable == "df"]$value == "NULL") {
stop("A df value must be provided in the recipe file")
} else { recipe$df <- x[variable == "df"]$value }
if(x[variable == "working.directory"]$value == "NULL") {
stop("A working.directory value must be provided in the recipe file")
} else {  recipe$df <- x[variable == "working.directory"]$value }
recipe$column.feature         <- x[variable == "column.feature"]$value
recipe$column.statistic       <- x[variable == "column.statistic"]$value
recipe$column.trait           <- x[variable == "column.trait"]$value
recipe$column.source          <- x[variable == "column.source"]$value
recipe$results.dir            <- x[variable == "results.dir"]$value
recipe$n.threads              <- eval(parse(text = x[variable == "n.threads"]$value))
recipe$signature.dir          <- x[variable == "signature.dir"]$value
recipe$gene.anno.file         <- x[variable == "gene.anno.file"]$value
recipe$grep.sig.pattern       <- x[variable == "grep.sig.pattern"]$value
recipe$noperm                 <- eval(parse(text = x[variable == "noperm"]$value))
recipe$thres.N.vector         <- eval(parse(text = x[variable == "thres.N.vector"]$value))
recipe$sig.annotation         <- eval(parse(text = x[variable == "sig.annotation"]$value))
recipe$overwrite.intermediate <- eval(parse(text = x[variable == "overwrite.intermediate"]$value))
recipe$model.banlist.grep     <- x[variable == "model.banlist.grep"]$value
recipe$prototyping            <- eval(parse(text = x[variable == "prototyping"]$value))
return(recipe)
}
parse_recipe("inst/extdata/project.recipe.csv")
#' Parse LSF project recipe file
#'
#' @param recipe.file recipe file
#' @return A list file with all included parameters
#' @keywords antagonism step1 LSF
#' @export
parse_recipe <- function(
recipe.file
){
x <- MultiWAS::return_df(recipe.file)
recipe <- list()
if(x[variable == "df"]$value == "NULL") {
stop("A df value must be provided in the recipe file")
} else { recipe$df <- x[variable == "df"]$value }
if(x[variable == "working.directory"]$value == "NULL") {
stop("A working.directory value must be provided in the recipe file")
} else {  recipe$df <- x[variable == "working.directory"]$value }
recipe$column.feature         <- x[variable == "column.feature"]$value
recipe$column.statistic       <- x[variable == "column.statistic"]$value
recipe$column.trait           <- x[variable == "column.trait"]$value
recipe$column.source          <- x[variable == "column.source"]$value
recipe$results.dir            <- x[variable == "results.dir"]$value
recipe$n.threads              <- eval(parse(text = x[variable == "n.threads"]$value))
recipe$signature.dir          <- x[variable == "signature.dir"]$value
recipe$gene.anno.file         <- x[variable == "gene.anno.file"]$value
recipe$grep.sig.pattern       <- x[variable == "grep.sig.pattern"]$value
recipe$noperm                 <- eval(parse(text = x[variable == "noperm"]$value))
recipe$thres.N.vector         <- eval(parse(text = x[variable == "thres.N.vector"]$value))
recipe$sig.annotation         <- eval(parse(text = x[variable == "sig.annotation"]$value))
recipe$overwrite.intermediate <- eval(parse(text = x[variable == "overwrite.intermediate"]$value))
recipe$model.banlist.grep     <- x[variable == "model.banlist.grep"]$value
recipe$prototyping            <- eval(parse(text = x[variable == "prototyping"]$value))
return(recipe)
}
parse_recipe("inst/extdata/project.recipe.csv")
parse_recipe("/sc/arion/projects/va-biobank/PROJECTS/2023_09_microglia_DGE_gtp_cdr/MG.DEG.combined.csv.gz")
MultiWAS::return_df("/sc/arion/projects/va-biobank/PROJECTS/2023_09_microglia_DGE_gtp_cdr/MG.DEG.combined.csv.gz")
parse_recipe("/sc/arion/projects/va-biobank/PROJECTS/2023_09_microglia_DGE_gtp_cdr/project.recipe.csv")
#' Parse LSF project recipe file
#'
#' @param recipe.file recipe file
#' @return A list file with all included parameters
#' @keywords antagonism step1 LSF
#' @export
parse_recipe <- function(
recipe.file
){
x <- MultiWAS::return_df(recipe.file)
recipe <- list()
if(x[variable == "df"]$value == "NULL") {
stop("A df value must be provided in the recipe file")
} else { recipe$df <- x[variable == "df"]$value }
if(x[variable == "working.directory"]$value == "NULL") {
stop("A working.directory value must be provided in the recipe file")
} else {  recipe$working.directory <- x[variable == "working.directory"]$value }
recipe$column.feature         <- x[variable == "column.feature"]$value
recipe$column.statistic       <- x[variable == "column.statistic"]$value
recipe$column.trait           <- x[variable == "column.trait"]$value
recipe$column.source          <- x[variable == "column.source"]$value
recipe$results.dir            <- x[variable == "results.dir"]$value
recipe$n.threads              <- eval(parse(text = x[variable == "n.threads"]$value))
recipe$signature.dir          <- x[variable == "signature.dir"]$value
recipe$gene.anno.file         <- x[variable == "gene.anno.file"]$value
recipe$grep.sig.pattern       <- x[variable == "grep.sig.pattern"]$value
recipe$noperm                 <- eval(parse(text = x[variable == "noperm"]$value))
recipe$thres.N.vector         <- eval(parse(text = x[variable == "thres.N.vector"]$value))
recipe$sig.annotation         <- eval(parse(text = x[variable == "sig.annotation"]$value))
recipe$overwrite.intermediate <- eval(parse(text = x[variable == "overwrite.intermediate"]$value))
recipe$model.banlist.grep     <- x[variable == "model.banlist.grep"]$value
recipe$prototyping            <- eval(parse(text = x[variable == "prototyping"]$value))
return(recipe)
}
parse_recipe("/sc/arion/projects/va-biobank/PROJECTS/2023_09_microglia_DGE_gtp_cdr/project.recipe.csv")
parse_recipe("/sc/arion/projects/va-biobank/PROJECTS/2023_09_microglia_DGE_gtp_cdr/project.recipe.csv")
parse_recipe("/sc/arion/projects/va-biobank/PROJECTS/2023_09_microglia_DGE_gtp_cdr/project.recipe.csv")$prototyping
signature.inventory <- fread("signature.inventory")
signature.inventory <- fread("/lab/r.projects/Microglia_GTG_CDR/results/GTP_CDR/intermediate.files/signature.inventory.csv")
signature.inventory
signature.dir          = "/sc/arion/projects/va-biobank/resources/CMap/cmap_l1000_2021-11-20/eachDrug/"
cmap.list <- list.files(signature.dir, full.names = T)
mylist <- cmap.list
mylist
x <- stats::setNames(mylist, basename(mylist))
x
x[1]
x[[1]]
paste0(sub("\\.RDS$", "", basename(i)))
i = x[[1]]
paste0(sub("\\.RDS$", "", basename(i)))
recipe
library(antagonist)
.libPaths()
eval(parse(text = "NA"))
sleep
list.dirs(paste0(results.dir, "/intermediate.files/5rank/S01A/)
MultiWAS::gv_install_packages(
cran.packages = c("cmapR", "optparse")
)
MultiWAS::gv_install_packages(
cran.packages = c("optparse")
bioc.packages = c("cmapR")
MultiWAS::gv_install_packages(
cran.packages = c("optparse"),
bioc.packages = c("cmapR")
)
antagonist::SIG.INFO.20211120
x <- antagonist::SIG.INFO.20211120
table(x$pert_type)
table(x$pert_iname)
order(table(x$pert_iname))
sort(table(x$pert_iname),decreasing = T)
antagonist::TRT_CP.INFO.20200324
View(antagonist::TRT_CP.INFO.20200324)
