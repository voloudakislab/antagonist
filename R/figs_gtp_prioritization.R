#' pvalue_qqplot
#'
#' Create a quantile-quantile plot with ggplot2. Script was adapted from: https://slowkow.com/notes/ggplot2-qqplot/. The null is the ordinates for probability plotting Generates the sequence of probability points (1:m - a)/(m + (1-a)-a) as generated by ppoints similarly to the one used in qqplot and qqnorm.
#'
#' Future improvements
#' - Stouffer's method or other zscore based meta-analysis
#' - Scaling prior to getting z combined
#'
#'
#' Assumptions:
#'   - Expected P values are uniformly distributed.
#'   - Confidence intervals assume independence between tests.
#'     We expect deviations past the confidence intervals if the tests are
#'     not independent.
#'     For example, in a genome-wide association study, the genotype at any
#'     position is correlated to nearby positions. Tests of nearby genotypes
#'     will result in similar test statistics.
#'
#' @param ps Vector of p-values or z-scores.
#' @param ci Size of the confidence interval, 95% by default.
#' @param type "pvalue" or "zscore" accepted for the provided statistic
#' @param stat.prefix text for the method or title of the qqplot
#' @param figsDir Default is "figs/"
#' @param figure.name Default is "qqplot_TWAS_vs_FunWAS"
#' @param save_plot Save plots in various useful formats
#' @return returns ggplot graph
#' @export
#' @examples
#' library(ggplot2)
#' gg_qqplot(runif(1e2)) + theme_grey(base_size = 24)

gtp_pvalue_qqplot  <- function(
    ps          = ppoints(1:10),
    ci          = 0.95,
    type        = c("pvalue", "zscore"),
    stat.prefix = "",
    ppoints.a   = NA,
    figsDir     = "figs/",
    figure.name = "pvalue_qqplot", # main body of the name of the figure
    save_plot   = F
) {
  library(ggplot2)
  # library(dplyr)
  # library(data.table)

  ### Calculate inflation λ ###
  gv_lambda_pvalue <- function(pvalues.atomic.vector) {
    set.seed(12345)
    # chisq <- qchisq(1-pvalues.atomic.vector, 1) # change this, is not precise enough
    chisq <- qchisq(pvalues.atomic.vector, 1, lower.tail=FALSE) # use this
    lambda <- median(chisq) / qchisq(0.5, 1)
    return (lambda)   }

  ### Prepare the values ###
  stat.prefix <- paste0(stat.prefix, " ") # add some space

  # P value sanity check
  if (type[1] == "pvalue") {
    if(!all(ps >= 0 & ps <= 1))
      stop("You say you provided p values but the value range is not [0,1]")}

  # Shape the df if we provided zscores
  if (type[1] == "zscore"){

    # z score to p value function
    zscore_to_pvalue <- function(z, min.p = 1e-300) {
      options(digits = 22)
      p <- 2*pnorm(-abs(z))
      p[p==0] = min.p # otherwise returns 0
      return(p) }
    ps             <- zscore_to_pvalue(ps)
  }

  # Generate df for plotting
  minus.log10.ps <- -log10(ps)
  n              <- length(ps)
  df <- data.frame(
    observed = -log10(sort(ps)), # because they are not already log transformed (decreasing = F)
    expected = -log10(ppoints(n, a = ifelse(is.na(ppoints.a), ifelse(n <= 10, 3/8, 1/2), ppoints.a))), # because they are not already log transformed (decreasing = F)
    clower   = -log10(qbeta(p = (1 - ci) / 2, shape1 = 1:n, shape2 = n:1)),
    cupper   = -log10(qbeta(p = (1 + ci) / 2, shape1 = 1:n, shape2 = n:1))
  )
  log10Pe <- bquote(paste("Expected ", .(stat.prefix), "-log"[10], plain(P), sep = ""))
  log10Po <- bquote(paste("Observed ", .(stat.prefix), "-log"[10], plain(P), sep = ""))

  p1 <- ggplot(df) +
    geom_ribbon(
      mapping = aes(x = expected, ymin = clower, ymax = cupper),
      alpha = 0.1) +
    geom_point(aes(expected, observed), shape = 16, size = 3) +
    geom_abline(intercept = 0, slope = 1, alpha = 0.5) +
    xlab(log10Pe) +
    ylab(log10Po) +
    theme_classic(base_size = 10) +
    scale_x_continuous(expand = c(0, .1)) + # expands only on the right side by 10%
    scale_y_continuous(expand = c(0, .15)) +
    theme(legend.position="none") +
    annotate(
      geom  = "text",
      x     = -Inf,
      y     = Inf,
      hjust = -0.15,
      vjust = 1 + 0.15 * 3,
      label = sprintf("λ = %.2f", gv_lambda_pvalue(ps)) #,
      # size = 8
    )
  return(p1)

}
